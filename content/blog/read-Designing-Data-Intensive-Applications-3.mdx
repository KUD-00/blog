---
title: "读Designing Data-Intensive Applications Chapter 3"
date: "2023-12-10"
description: "more!"
image: /images/blog/conbini-student.jpg
authors:
  - KUD
---

两类存储引擎
- 基于日志
- 基于页面，如B树

最简单的数据库：
```bash
db_set () {
    echo "$1,$2" >> database
}

db_get () {
    grep "^$1," database | sed -e "s/^$1,//" | tail -n 1
}
```

索引是从主数据派生出来的额外结构，不影响数据库内容；只影响查询性能。维护额外结构会带来开销，尤其是写入时。简单地追加到文件的性能很难被超越，因为是最简单写操作。任何类型的索引通常都会减慢写入，因为需要更新索引

存储系统中重要权衡：索引可加快查询速度，但会减慢写入速度。因此数据库通常不会默认对所有内容进行索引，而是要求开发者手动选择索引，使用对app的典型查询模式的了解

假设数据存储仅包括追加到文件，最简单的索引策略是：保持一个内存中的哈希映射，每个键都映射到数据文件中字节偏移量——可找到值的位置

这是 Bitcask（Riak 中默认存储引擎）所做的。Bitcask 提供高性能读写，前提是所有键都适合于可用的 RAM，因为哈希映射完全在内存中。值可使用比可用内存更多的空间，因为它们可只通过一次磁盘寻道就从磁盘加载。如果数据文件部分已在文件系统缓存中，读取根本不需任何磁盘 I/O

Bitcask 这样的存储引擎适合每个键的值经常更新的情况。如键可能是猫视频的 URL，值可能是它被播放的次数。这种工作负载中有很多写操作，但并不是太多不同的键——你有每个键大量的写操作，但将所有键保持在内存中是可行的

how do we avoid eventually running out of disk space? 解决方案是通过关闭达到一定大小的段文件，在新的段文件中进行后续写入，将日志分割成一定大小的段。可对这些段进行压缩。压缩意味着在日志中丢弃重复的键，且只保留每个键的最新更新

段在写入后不会被修改，所以合并的段被写入新文件。合并和压缩段可以在后台线程中完成，同时仍然可继续使用旧的段文件处理读请求，并将写请求写入最新段文件。合并过程完成后将读请求切换到使用新合并的段而不是旧段，旧段文件可被删除

追加只读日志看起来浪费：为什么不就地更新文件，用新值覆盖旧值呢？追加只读设计的优点：
- 追加和段合并是顺序写操作，比随机写入快得多，尤其在HDD上。一定程度上顺序写入在基于SSD上也是可取的
- 如果段文件是追加只读或不可变的，那么并发和崩溃恢复会简单得多。如不必担心在值被覆盖时发生崩溃的情况，留下一个包含部分旧值和部分新值拼接在一起的文件
- 合并旧段避免了数据文件随时间碎片化的问题

哈希表索引也有其局限性：
- 哈希表必须适合内存，如有非常大量的键就不行了。原则上可在磁盘上维护哈希映射，但很难让它表现良好。它需要大量随机访问I/O，当它变满时扩容成本高昂，且哈希冲突需要复杂逻辑处理
- 范围查询效率不高。如你不能轻易地扫描所有在kitty00000和kitty99999之间的键——必须在哈希映射中单独查找每个键

每个日志结构化存储段都是键值对的序列。这些对按照它们被写入的顺序出现，而日志中后面的值会覆盖日志中同一键的早期值。除此之外文件中键值对的顺序并不重要

可对段文件格式做简单改变：要求键值对序列按键排序。将这种格式称为排序字符串表，简称为SSTable。这种格式我们不能立即将新的键值对追加到段中，因为写入按任何顺序发生

SSTables与带有哈希索引的日志段相比几个优势：
- 合并段简单高效，即使文件大于可用内存。类似于归并排序算法
- 为在文件中找到特定键，不再需要在内存中保留所有键的索引。假设正寻找键handiwork，但不知道该键在段文件中的确切偏移量。然而知道键handbag和handsome的偏移量，知道handiwork必须出现在两者间。可跳转到handbag的偏移量，并从那里扫描
- 仍需内存中的索引指示某些键的偏移量，但它可以是稀疏的：隔几千字节的段文件就有一个键就足够，因为几千字节可非常快速地扫描

由于读取请求无论如何都需要扫描请求范围内的几个键值对，因此可以将这些记录分组成一个块，并在写入磁盘之前对其进行压缩（如图3-5中的阴影区域所示）。稀疏内存索引的每个条目都指向压缩块的起始处。除了节省磁盘空间外，压缩还减少了I/O带宽的使用

要构建和维护SSTable重要的问题是，如何让数据按键排序？写入操作可按任何顺序发生

在磁盘上维护排序结构是可能的（B-树），但在内存中维护它要容易得多。有很多树数据结构可用，如红黑树或AVL树。使用它们可按任何顺序插入键，并按排序顺序读回它们

现在可使我们的存储引擎如下工作：
- 写入请求到来时，将其添加到一个内存中的平衡树数据结构中（如红黑树）。内存中的树有时称memtable
- memtable大小超过某个阈值——通常是几兆字节——将其作为SSTable文件写入磁盘。这可高效完成，因为树已经按键排序了键值对。新的SSTable文件成为数据库的最新段。将SSTable写入磁盘时，写入可以继续到新的memtable实例
- 为处理读请求，首先尝试在memtable中找到键，然后在最新磁盘段中找到键，然后在次新的段中找到键，依此类推
- 不时地在后台运行合并和压缩过程，以合并段文件并丢弃被覆盖或删除的值

这种方案只有一个问题：如果数据库崩溃，最近的写入（在memtable中但还没写入磁盘）会丢失。为避免问题，可在磁盘上保持一个单独的日志，每个写入都立即追加到其中。该日志不是排序的但不重要，因为它的目的是在崩溃后恢复memtable。每次将memtable写入SSTable时，相应的日志可被丢弃

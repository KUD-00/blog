---
title: "读gRPC Microservices in Go第一章"
date: "2024-01-05"
description: "micro"
image: /images/blog/starfish-girl.jpg
authors:
  - KUD
---

微服务可用任何语言实现，Go 特别适用于构建高性能的云原生分布式应用程序，如大规模Kubernetes中的微服务。使用gRPC通信的微服务使许多公司能基于其业务能力实现小型服务，让这些服务与彼此和公共服务顺畅通信。借助Go语言这些服务的分布变得更加容易，因为它具有快速编译能力，能生成可执行二进制

gRPC是开源远程过程调用框架，它帮助连接服务，内置了负载均衡、追踪、容错和安全支持。优势是为多种语言生成服务器和客户端存根(stubs)（即客户端上实现与服务相同方法的对象），存根在消费者项目中用于调用远程服务方法，在服务器项目中用于定义这些服务方法背后的业务逻辑
> - 服务器存根：服务器端存根是一种骨架代码，用于定义服务接口。开发者可在这个骨架基础上实现具体业务逻辑。如定义了一个服务方法getUser，gRPC会生成相应的存根，你只需填充这个方法的具体实现（如如何检索用户数据）
> - 客户端存根：客户端存根是一种代理对象，提供与服务器端定义的同样方法。客户端开发者可使用这些方法来调用远程服务，就像调用本地方法一样。如客户端上的getUser方法会通过网络与服务器上的同名方法通信

微服务是面向服务的架构形式，将应用程序定义为松散耦合、细粒度的服务，这些服务可独立实现、部署和扩展

借助gRPC微服务中的挑战，如处理网络故障和对服务通信应用TLS（传输层安全）都可以消除

> 总之就是gRPC提供了很多功能

gRPC比其他协议（如用JSON/XML通信的REST）提供更好性能安全，因为它使用协议缓冲区，且在TLS上的HTTP/2非常直接。
- 协议缓冲区(Protobuf)，是不论语言和平台的用于序列化结构化数据的机制。使gRPC能在服务器和客户端快速序列化成小巧紧凑的消息
- HTTP/2通过服务器端推送、多路复用和头部压缩提高了性能

> 服务器端推送 (Server Push) 是HTTP/2的功能，允许服务器主动向客户端发送资源，不需客户端明确请求。这功能对提升页面加载速度尤其有用
> 当客户端请求页面时，服务器不仅发送请求的HTML文件，还可发送页面中将要用到的其他资源（如CSS文件、JavaScript文件、图像等）
> 服务器通过`PUSH_PROMISE`帧通知客户端它将发送哪些附加资源，这样客户端不会再次请求这些资源

> 多路复用 (Multiplexing) 是HTTP/2中的核心改进，允许在单一TCP连接上同时发送多个请求和响应
> HTTP/2将请求和响应分解为更小的帧，并在一个TCP连接上同时交错发送这些帧
> 每个帧都属于特定的流（stream），流是独立请求或响应的标识
> 优势：
> - 减少由于TCP连接建立和拥塞控制引起的延迟
> - 允许同时加载页面多个部分，而不是按顺序加载

> 头部压缩 (Header Compression): HTTP/2通过HPACK算法压缩头部信息，减少传输数据量
> HTTP/2使用静态和动态两种字典存储和传输常见的头部字段
> 静态字典包含常见的头部字段名和值，动态字典记录在通信过程中出现的头部字段
> 对于每个请求和响应，只传输字典中的索引和未出现过的新头部字段大大减少了传输头部大小

假设有结账服务和支付服务，允许客户结账购物篮后触发支付服务。要访问支付服务需在某处（如共享库）拥有请求和响应模型，以便轻松访问

> 请求和响应模型是指在客户端和服务器之间进行通信时所使用的数据结构或格式
> 微服务架构中服务间的交互通过网络进行。为简化这些服务间交互，常在共享库（shared library）中定义请求和响应模型。好处是实现了代码的复用和标准化，使不同的服务可更容易、更一致地通信

微服务中重用共享请求和响应模型看起来方便，但尤其是当您为每个微服务使用不同语言时，这不是好做法
- 在结账服务中复制模型，通常是通过创建另一个数据类来构建请求对象和反序列化响应对象，是更好的选择。这是为了防止错误的抽象，正如[“一点点重复远比错误的抽象便宜”](https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction)
- 简单方法：gRPC定义消息并生成客户端存根，这样就可直接在任何语言中注入依赖

> 共享库是特定语言编写的，可能限制其他服务使用不同语言时的兼容性。相反复制模型（即在每个服务中独立定义请求和响应模型）提供更大灵活性
> 共享库可能导致错误抽象，即一个服务的改变需修改共享库，进而影响到所有使用该库的服务。复制模型避免了这种紧密耦合，每个服务可独立演化而不影响其他服务
> gRPC可定义统一的消息格式（Protocol Buffers），且gRPC自动生成各种语言的客户端和服务器端代码。每个服务可使用生成的代码构建请求对象和反序列化响应对象，无需手动编写通信代码
> gRPC使用Protocol Buffers定义强类型接口，比JSON或XML等格式更严格清晰，减少解析错误和数据不一致的风险

[gRPC越来越受欢迎](https://star-history.com/#grpc/grpc&Date)。只需决定需要拥有什么样的业务对象。一旦选择结账模型需要的字段，可引入相应请求和响应消息。这些消息只是在IDL（接口定义语言）中的定义，与任何语言规范无关。定义了消息规范后，可生成特定语言实现，以便任何消费者都可依赖该来源。服务器端开发语言可与客户端不同，因为服务器端方法可为客户端特定语言生成存根

除业务对象还可类似定义服务方法并生成实现。初始化gRPC客户端后这些服务功能可在消费者端调用；这个客户端是开箱即用的

幂等性是成功容错环境的关键，因为需要确保一旦在失败或未达到预期状态的情况下重试操作时，使用相同参数不会改变实际资源内容。如希望在响应中出现网络故障时重试删除用户操作。如果操作即使多次调用也返回相同结果，称这个操作是幂等的

如果操作不适合幂等用例，则必须在响应消息中提供适当的验证错误，以知道何时停止重试操作。一旦保证了这种幂等性或适当的验证，那么在gRPC端定义重试策略就只是定义问题。容错还专注于速率限制、断路器和故障注入等主题

> 网络服务中，尤其是可能存在网络问题或其他故障情况下，客户端可能会重试不幂等操作，导致不期望的副作用（如重复扣费）
> 为解决问题，服务在响应消息中应提供适当验证错误。意味着当操作不应被重试时（如它已执行了），服务应返回明确的错误消息告诉客户端不要再重试操作
> gRPC支持客户端和服务器端的重试策略，可配置这些策略来适应不同操作和故障情况

大多数系统可能需要安全层来保护产品免受未经验证来源的侵害。gRPC鼓励在SSL/TLS上使用HTTP/2来认证和加密客户端和服务器间交换的数据。可使用SSL/TLS、ALTS（应用层传输安全）或基于令牌的认证系统轻松设置该认证系统

有时可能需要将响应数据分成几块，以分页方式减少带宽并快速返回给用户。如果用户只对特定页面感兴趣，则同时返回所有数据没有意义
- gRPC中除了分页，还可将这些数据流式传输给消费者，而不是强迫用户进行分页以迭代地获取数据。
- 流式处理不一定要在服务器端进行；也可在客户端或同时在双方进行，称双向流式处理。典型的流式处理用例中，只打开一次连接，数据通过这个打开的连接进行流式传输

> 分页 (Pagination) 目的：当服务器有大量数据需发给客户端时，一次性发送所有数据可能导致带宽浪费和响应延迟。分页是常见解决方案，服务器将数据分成“页”，每页包含一定数据项。客户端首先请求第一页数据，如需更多数据，可继续请求后续页。这可减少单次请求的数据量，从而减轻服务器负载，加快响应时间
> 流式传输 (Streaming): 与传统请求/响应模型不同，流式传输允许数据在客户端和服务器间持续流动
> - 应用场景：流式传输适用于需要实时处理大量数据的场景，如视频播放、实时数据分析等
> - 优势在于只打开一次连接，数据可通过已打开连接持续传输，提高效率并减少连接开销

REST（表述性状态转移）是微服务广泛采用的协议。但如果有严格的要求，如低延迟、多语言系统支持等，可能会考虑gRPC
- REST基于HTTP 1.0，在客户端和服务器间以JSON/XML格式交换消息
- gRPC基于RPC架构，使用协议缓冲区的二进制格式在HTTP 2.0协议上交换数据
- 并不意味着REST不兼容HTTP 2.0；可使用自定义实现基于该协议设置REST服务，以便它是gRPC中的内置功能

由于gRPC内置了HTTP 2.0支持，还可在客户端和服务器间使用一元和双向流式传输，从而实现高速通信。使用REST服务的默认设置，多个客户端-服务器通信可能导致整体系统性能的延迟

一些情况下REST比gRPC更有利。如REST协议在所有类型的浏览器中都支持。由于gRPC支持有限可能需使用代理层，如[gRPC Web](https://github.com/grpc/grpc-web)，以便轻松与gRPC服务器通信

gRPC有许多优势，如能定义消息以便于在服务间轻松交换数据。可读性而言，REST的JSON/XML使用具有优势，如果没有对更改字段的显式业务验证，则可自由更改请求。相比之下gRPC中进行更改时，需遵循规则

gRPC内置了客户端和服务器存根生成机制，而您需要在REST中使用诸如Swagger Codegen之类的框架来生成客户端模型。这在您同时维护多个服务和多个客户SDK时尤其关键。

如果您对浏览器支持有严格要求，那么您需要考虑使用REST，因为您最终需要设置另一层来转换HTTP/2和HTTP/1。但是，您仍然可以用gRPC进行服务间通信，并将gRPC负载均衡器（http://mng.bz/BmZ8）连接到该服务池，以便公开API以兼容REST，我们将在第9章中详细看到。其他替代方案包括Twirp（https://github.com/twitchtv/twirp），这是一个基于Protobuf的RPC框架。Twirp允许您为gRPC服务启用REST层，使您能够访问端点，例如以下示例，该示例发送带有JSON有效负载的POST请求：
```bash
curl -X "POST"
- H "Content-Type: application/json"
-d '{"name": "dev-cluster"}'
➥ http://localhost:8080/twirp/github.com/huseyinbabal/microservices-proto/cluster/Create
```

多语言开发环境非常适合gRPC集成，因为在结账服务中使用Python客户端访问使用Java编写的支付服务，通过客户端存根生成非常容易。您可以将相同的策略应用于公共消费者的SDK生成。此外，每当您更改服务定义时，客户端的测试都会失败，这是您微服务的合适验证机制。

对于只包含一到两个服务的简单应用程序，例如创业项目，gRPC可能不是合适的选择，因为维护包含服务定义的proto文件并不容易，尤其是对于没有经验的用户。

然而，将gRPC通信用于内部服务是可以接受的，但向客户公开gRPC接口可能不是理想的选择，尤其是如果没有用于gRPC服务通信的客户端SDK。如果您更喜欢公开gRPC而不维护消费者的SDK，那么最好与他们共享您的服务定义，或提供关于如何向您的gRPC服务发起gRPC调用的清晰说明。

微服务项目充满挑战，尤其是在项目开始时，您会经常在架构决策会议中听到以下问题：
- 让我们实现微服务，但应该多微小？
- 我们需要基于哪种策略来构建/分解服务？

根据业务能力划分微服务是一种选择（http://mng.bz/rWnD），我们将使用这种区分，专注于现实生活中的用例，并在接下来的章节中实现它们。如图1.1所示，我们有五个服务提供不同的业务功能，例如Shipping服务将产品运送给客户，以及使用结账阶段的购物车信息向客户的信用卡收费的支付服务。有五个业务能力：产品、购物车、结账、支付和运输。它们使用生成的存根连接（例如，结账使用Shipping gRPC存根调用Shipping服务功能）。

单体到微服务的分解将替换服务函数调用为网络调用，这意味着您需要实现一个容错的客户端来进行服务间通信。gRPC提供了基本的连接池和资源访问等功能，因此在将自动生成的存根添加到Consumer服务作为Go依赖后，可以使用它们的gRPC存根在客户端访问服务函数。如图1.1所示，结账服务可以调用购物车服务以获取购物车商品、运输服务以获取客户地址，以及支付服务以向客户的信用卡收费，方法是将分别生成的运输、购物车和支付服务的存根添加到结账服务作为Go依赖。我们将在第5章详细讨论依赖管理；您将学习如何处理依赖关系以及如何在CI（持续集成）管道中自动化它们。

微服务架构为多语言开发环境打开了大门，这对于选择不同用例的合适语言非常有帮助。它还允许使用各种技术，例如在需要关系表结构的情况下使用MySQL，或在需要文档型数据模型的情况下使用Mongo。微服务架构还可以帮助您构建不同的小团队，将代码所有权分配给特定的服务池。

管理应用程序环境可能不是真正的问题，如果您有一个单体应用程序，因为您可以将这个应用程序部署到一组虚拟机中，并且一个典型的负载均衡器可以处理流量。不充分的资源利用率、扩展问题和高风险的部署促使人们转向微服务架构。但是，一旦您做出了转换，因为每个服务都是独立的，您需要开始考虑需要适当管理的分布式环境。

Kubernetes是一个开源容器编排平台，已经证明了自己在应用程序部署管理和许多其他生产级用例中的有效性。图1.1中显示的服务都将是云原生应用程序，并将为CI/CD管道中的使用定义Kubernetes部署规范。此外，每个服务都将在容器中运行，并可以根据负载水平进行扩展。

gRPC需要一个服务器地址来拨入以调用服务功能。Kubernetes的发现系统非常适合找到正确的地址，因为服务器地址是在服务规范中定义的微服务的服务名称。假设您为您的服务有适当的命名约定。在这种情况下，您还可以在消费者和服务之间实现完美的集成，无需借助服务发现产品来查看特定服务的实际地址。

每个服务都可以有不同的行为，如资源请求、扩展因子、语言运行时等。同样，它们只是Kubernetes部署中的配置，可以针对每个服务进行适当配置。例如，假设产品服务由于大多数客户在白天搜索和查看产品而需要比其他服务更多的容量或扩展因子。您不需要像在单体应用程序中那样同时扩展Kubernetes中的所有服务。这可以通过向特定服务添加扩展因子和资源容量来处理。

每个服务的主要输出将是一个云原生应用程序，这意味着您可以将此服务部署到任何其他容器运行时，例如AWS Fargate、AWS ECS，甚至用于本地开发的Docker等，只需稍作修改。

在微服务环境中，有许多操作是自动化的候选对象。服务工件构建、特定语言的gRPC存根生成、测试、代码质量检查以及服务部署等都是一些众所周知的例子。您在这个分布式系统中拥有的自动化越多，在开发生命周期中的压力就越小。

您可以在本地环境中轻松使用gRPC工具生成存根，但是如果在向远程仓库推送一些更改时生成它们不是更好吗？在将它们合并到主分支后，您还可以生成工件以部署它们到实验环境或稳定环境。现代版本控制系统（VCS）提供商，如GitHub、GitLab和Bitbucket，已经具有这种集成，因此在这种自动化水平上不需要太多自定义实现。

CI/CD作业执行后的绿色勾号并不意味着一切都好；应该有一种方法来检查是否使用了正确的机制。良好的单元测试覆盖率；适当的集成测试来检查第三方集成，如MySQL、Kubernetes或AWS；服务间通信的合同测试；静态代码分析；和漏洞检查是在主分支中拥有可靠代码库的良好开端。

在成功且可靠的代码库之后，可以生成并标记工件，以便部署到用户验收测试（UAT）环境，然后是最终用户的生产环境。部署方法论的一些最佳实践包括滚动升级、金丝雀部署和蓝绿部署。部署的主要目标是将工件（在我们的案例中是Docker映像）运送到Kubernetes环境，并准备在需要时回滚。做出回滚操作的决定并不容易。然而，如果您有适当的监控系统，您可以追踪错误率和用户反馈来决定何时回滚或对当前版本引入紧急修复。

监控是一种机制，允许团队观察和理解他们系统的状态，而可观察性是一种使团队能够调试系统的机制。主要通过指标、日志和追踪实现可观察系统。追踪上下文对于查看任何特定请求的生命周期至关重要，我们将在第9章详细看到。假设一个消费者使用SDK通过API网关访问API。它将请求传播到四到五个下游服务以处理所有操作，然后返回给客户。成功的响应并不意味着一切都好；如果这个生命周期中存在延迟，那就不好。在检测到延迟之后，可以通过按痕迹ID分组来分析请求流，这些痕迹ID包含有用的信息。我们将在第9章详细看到，可以通过一个简单的中间件快速将痕迹ID注入到请求和响应头中。

监控是微服务架构的关键部分，因为一旦您将单体应用程序分解为微服务架构，您就必须引入解决方案以获得更好的可见性。服务级指标、总体延迟和服务间通话层次结构是您可能希望在监控仪表板上看到的一些解决方案。除了系统级指标外，服务的日志也很必要，因为它们允许您追踪应用程序级异常，例如错误率的增加。

为您的系统提供仪表板、面板和图表是更好可观察性的良好开端。然而，我们应该专注于引入新的指标，并基于这些工具创建特定的警报，以在您远离仪表板时通知您。例如，Prometheus（https://prometheus.io），一个开源事件监控和警报工具，可以用来收集系统和应用程序指标，并可以基于这些指标配置新的警报，例如“一旦特定服务的内存使用率> 80%，则通知”。日志也是洞察的良好来源，因为您可以实时计算错误率。您甚至可以在现代日志管理工具中根据日志模式创建警报配置，例如Elastic Stack（Elasticsearch、Logstash和其他Elastic集成产品）。

良好的监控设置可以提供对服务间通信和服务到第三方集成的洞察。例如，它将可以检测服务与数据库之间或服务与组织控制之外的第三方API之间的性能问题。

公共访问对于您的产品和您的业务声誉非常重要。例如，如果用户可以向您的产品发送无限制的请求，这是公共访问不良架构设计的标志，因为没有限制系统的产品会导致服务器端资源耗尽，对性能产生负面影响。

API网关被广泛用于通过遵循某些原则来防止这类情况，例如快速建立适当的认证/授权系统，引入速率限制以限制用户的请求容量等。如果您已经使用Kubernetes，您可以通过内置功能来处理这一点，例如向NGINX控制器添加授权和速率限制配置；否则，您还有其他选择，例如使用API网关产品。

资源命名也至关重要，因为它会影响产品文档的质量。如果为端点使用了适当的命名，阅读API文档和顺利使用这些API端点就更容易。您还可以选择为您的产品实现SDK，这样消费者就可以依赖该SDK功能，而不是尝试构建请求、发送到API端点并处理响应。

软件开发团队的根本目标是实现一系列功能，以形成产品并创造直接或间接的商业价值。这种产品可以作为一个包分发，可以离线安装在电脑上，或者是基于互联网的在线使用。每种编程语言都有自己的打包方法；例如，对于Java项目，你可以使用WAR或JAR文件，或者对于Go项目，使用二进制可执行文件。我们称之为单体架构：一个或多个功能/模块作为一个产品打包，完成相关任务，在一个可分发的对象中。当出现可扩展性问题时，像微服务架构这样的替代方案很受欢迎，因为应用程序根据它们的业务能力被分解成服务。这种分解使每个服务能够独立部署，我们将在第8章详细讨论。服务间通信的稳定性对于在服务间提供数据一致性至关重要

---
title: "读linux programming interface chapter 1-3 "
date: "2023-10-27"
description: "a dream"
image: /images/blog/pink-sky-gril.jpg
authors:
  - KUD
---

Linux内核可执行文件通常位于路径/boot/vmlinuz或类似的地方。这个文件名的来源是历史的。在早期的UNIX实现中，内核被称为unix。后来支持虚拟内存的UNIX实现将内核重命名为vmunix。在Linux上，文件名反映了系统名称，其中z替换了最后的x，表示内核是一个压缩的可执行文件。

虚拟内存管理两个主要优点：
– 进程彼此隔离，与内核隔离，这样一个进程不能读取或修改另一个进程或内核的内存。
– 只有进程的一部分需要保留在内存中，从而降低了每个进程的内存要求，并允许更多的进程同时保存在RAM中。这增加了CPU的利用率，因为它增加了在任何给定时间，至少有一个进程可以被CPU执行的可能性。

内核基本上提供一种文件类型：一个连续的字节流，在磁盘文件、磁盘和磁带设备的情况下，可以使用lseek()系统调用随机访问。

许多应用程序和库将换行字符（十进制ASCII代码10，有时也被称为换行）解释为终止一行文本并开始另一行。UNIX系统没有文件结束字符；通过返回没有数据的读取来检测文件的结尾。

为了执行文件I/O，C程序通常使用标准C库中包含的I/O函数。这组函数，被称为stdio库，包括fopen()、fclose()、scanf()、printf()、fgets()、fputs()等。stdio函数基于I/O系统调用（如open()、close()、read()、write()等）之上

---

子进程继承了父进程数据、堆栈和堆段的副本，然后可以独立地修改这些副本。（放置在标记为只读的内存中的程序文本由这两个进程共享。）

子进程继续在与父进程相同的代码中执行不同的函数，或者经常使用execve()系统调用加载并执行一个全新的程序。execve()调用销毁现有的文本、数据、堆栈和堆段，并根据新程序的代码替换它们。

进程可以通过两种方式之一终止：通过使用_exit()系统调用（或相关的exit()库函数）请求自己的终止，或者通过传递信号被杀死。在任何情况下，进程都会产生一个终止状态，这是一个小的非负整数值，父进程可以使用wait()系统调用查看它。在调用_exit()的情况下，进程明确地指定自己的终止状态。如果进程被信号杀死，终止状态根据导致进程死亡的信号类型设置。

每个进程都有一些关联的用户ID（UIDs）和组ID（GIDs）。这些包括：
- 实际用户ID和实际组ID：这些标识进程所属的用户和组。新进程从其父进程继承这些ID。登录shell从系统密码文件中的相应字段获取其实际用户ID和实际组ID。
- 有效用户ID和有效组ID：这两个ID（结合一会儿要讨论的补充组ID）用于确定进程在访问受保护的资源（如文件和进程间通信对象）时的权限。通常，进程的有效ID与相应的实际ID具有相同的值。更改有效ID是允许进程假定其他用户或组的特权的机制，如下所述。
- 补充组ID：这些ID标识进程所属的其他组。新进程从其父进程继承其补充组ID。登录shell从系统组文件获取其补充组ID。

---

传统上，在UNIX系统上，特权进程是其有效用户ID为0（超级用户）的进程。这样的进程绕过内核通常应用的权限限制。相反，术语非特权（或非特权）适用于由其他用户运行的进程。这样的进程有一个非零的有效用户ID，并必须遵守内核强制执行的权限规则。

从2.2版本的内核开始，Linux将传统授予超级用户的权限划分为一组称为权限能力（capabilities）的独立单元。每个有特权的操作都与某个特定的能力关联，进程只有在拥有相应的能力时才能执行操作。传统的超级用户进程（有效用户ID为0）对应于启用了所有权限能力的进程。

为进程授权一部分权限能力允许它执行通常允许超级用户执行的某些操作，同时阻止它执行其他操作。

启动系统时，内核创建了一个特殊的进程，称为init，也被称为“所有进程的父进程”，它源自/sbin/init程序文件。系统上的所有进程都是由init或其后代使用fork()创建的。init进程始终具有进程ID 1，并以超级用户权限运行。init进程不能被杀死（即使是由超级用户），并且只有在系统关闭时才终止。init的主要任务是创建并监视运行系统所需的一系列进程

---

守护进程(daemon)是一种特殊的进程，它由系统以与其他进程相同的方式创建和处理，但它具有以下特点：
- 长寿命。守护进程通常在系统启动时启动，并在系统关闭时一直存在。
- 在后台运行，并且没有控制终端，从中它可以读取输入或写入输出。

守护进程的例子包括syslogd，它在系统日志中记录消息，以及httpd，它通过超文本传输协议（HTTP）提供网页。

C程序可以使用外部变量（char **environ）访问环境，各种库函数允许进程检索和修改其环境中的值。

---

每个进程都会消耗资源，如打开的文件、内存和CPU时间。使用setrlimit()系统调用，进程可以为其消耗的各种资源设定上限。每个这样的资源限制都有两个关联的值：一个软限制，限制进程可能消耗的资源量；以及一个硬限制，它是软限制可能调整到的值的上限。一个无特权的进程可能会将其某个特定资源的软限制更改为从零到相应的硬限制之间的任何值，但只能降低其硬限制。

当使用fork()创建新进程时，它会继承其父进程的资源限制设置。

可以使用ulimit命令（在C shell中为limit）调整shell的资源限制。这些限制设置是由shell创建的子进程继承的，这些子进程用于执行命令。

> ulimit是shell built-in，所以是用户级别的，只影响本shell会话，它可以控制很多资源限制上限

```bash
 (>∀<)  ulimit -a
real-time non-blocking time  (microseconds, -R) unlimited
core file size              (blocks, -c) unlimited
data seg size               (kbytes, -d) unlimited
scheduling priority                 (-e) 0
file size                   (blocks, -f) unlimited
pending signals                     (-i) 127195
max locked memory           (kbytes, -l) 8192
max memory size             (kbytes, -m) unlimited
open files                          (-n) 1024
pipe size                (512 bytes, -p) 8
POSIX message queues         (bytes, -q) 819200
real-time priority                  (-r) 0
stack size                  (kbytes, -s) 8192
cpu time                   (seconds, -t) unlimited
max user processes                  (-u) 127195
virtual memory              (kbytes, -v) unlimited
file locks                          (-x) unlimited```
---

mmap()系统调用在调用进程的虚拟地址空间中创建一个新的内存映射。

映射分为两类：
- 文件映射将文件的一个区域映射到调用进程的虚拟内存中。一旦映射，可以通过在相应内存区域的字节上进行操作来访问文件的内容。根据需要，映射的页面会自动从文件中加载。
- 相反，匿名映射没有相应的文件。相反，映射的页面初始化为0。

一个进程的映射中的内存可能与其他进程中的映射共享。这可能是因为两个进程映射了文件的相同区域，或者是因为由fork()创建的子进程从其父进程继承了映射。

当两个或更多进程共享相同的页面时，每个进程可能会看到其他进程对页面内容所做的更改，具体取决于映射是作为私有还是共享创建的。当映射是私有的，对映射内容的修改对其他进程不可见，并且不传递到底层文件。当映射是共享的，对映射内容的修改对共享相同映射的其他进程是可见的，并且传递到底层文件。

内存映射有多种用途，包括从可执行文件的相应段初始化进程的文本段，分配新的（填充为零的）内存，文件I/O（内存映射I/O）和进程间通信（通过共享映射）。

```c
#include <sys/mman.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main() {
    int fd;
    char *mapped;

    /* 打开文件 */
    fd = open("example.txt", O_RDWR);
    if (fd < 0) {
        perror("open");
        return 1;
    }

    /* 将文件映射到内存 */
    mapped = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (mapped == MAP_FAILED) {
        perror("mmap");
        close(fd);
        return 1;
    }

    /* 通过内存写入数据 */
    strcpy(mapped, "Hello, mmap!");

    /* 解除映射和关闭文件 */
    munmap(mapped, 4096);
    close(fd);

    return 0;
}
```

---

静态库是早期UNIX系统上唯一的库类型。本质上是已编译的对象模块的结构化捆绑包。要使用静态库中的函数，我们在构建程序的链接命令中指定该库。链接器在将主程序的各种函数引用解析到静态库中的模块之后，从库中提取所需的对象模块的副本，并将这些副本复制到生成的可执行文件中

缺点是在不同的可执行文件中复制对象代码会浪费磁盘空间。当同时执行使用相同库函数的静态链接的程序时，会出现相应的内存浪费；每个程序都需要其自己的函数副本驻留在内存中; 如果库函数需要修改，在重新编译该函数并将其添加到静态库之后，所有需要使用更新的函数的应用程序都必须重新与库链接。

共享库的设计是为了解决静态库的问题。如果程序链接到共享库，那么链接器只写入一个记录到可执行文件，指示在运行时可执行文件需要使用该共享库。当可执行文件在运行时加载到内存中时，称为动态链接器的程序确保找到并加载所需的共享库到内存，并执行运行时链接，将可执行文件中的函数调用解析为共享库中的相应定义。在运行时，共享库的代码只需要一个副本驻留在内存中；所有正在运行的程序都可以使用该副本。

---

进程间通信（IPC）机制：
- 信号，用于指示事件已发生；
- 管道（pipes）和FIFOs，可以用来在进程之间传输数据；
- 套接字，可用于从一个进程传输数据到另一个进程，无论是在同一主机计算机上还是通过网络连接的不同主机上；
- 文件锁定，允许进程锁定文件的区域，以防止其他进程读取或更新文件内容；
- 消息队列，用于在进程间交换消息（数据包）；
- 信号量，用于同步进程的行为;
- 共享内存，允许两个或多个进程共享一块内存。当一个进程更改共享内存的内容时，所有其他进程都可以立即看到这些更改。

当进程接收到信号时，它会：
- 忽略信号；
- 被信号杀死；
- 被暂停，直到稍后收到特殊目的信号后恢复。

对于大多数信号类型，程序可以选择忽略信号，或建立一个信号处理程序，而不是接受默认信号操作。信号处理程序是程序员定义的函数，当信号被传递到进程时自动调用。此函数执行与生成信号的条件相适应的某些操作。

在生成和传递之间的时间间隔内，信号对于进程来说被认为是待处理的。通常，待处理的信号会在下次计划运行接收进程时立即被传递，或者如果进程已经在运行，则立即被传递。但是，也可以通过将其添加到进程的信号掩码来阻止信号。如果在阻塞信号时生成了一个信号，它将保持挂起状态，直到稍后被解除阻塞（即从信号掩码中删除）。

---

session是一个进程组（任务）的集合。一个session中的所有进程都有相同的会话标识符。会话领导是创建session的进程，其进程ID成为会话ID。

session主要由作业控制shell使用。由作业控制shell创建的所有进程组都属于与shell相同的会话，而shell是会话领导。

session通常有一个关联的控制终端。当会话领导进程首次打开终端设备时，就会建立控制终端。对于交互式shell创建的会话，这是用户登录的终端。一个终端最多只能是一个会话的控制终端。

由于打开控制终端，会话领导成为终端的控制进程。如果发生终端断开（例如，关闭终端窗口），控制进程会收到一个SIGHUP信号。

在任何时候，会话中的一个进程组是前台进程组（前台任务），它可以从终端读取输入并发送输出。如果用户在控制终端上键入中断字符（通常是Control-C）或挂起字符（通常是Control-Z），则终端驱动程序发送一个信号，该信号杀死或挂起（即停止）前台进程组。会话可以有任意数量的后台进程组（后台任务），这些任务是通过用和字符（&）结束命令创建的。

---

伪终端是一对连接的虚拟设备，称为主设备和从设备。这对设备提供了一个IPC通道，允许数据在两个设备之间双向传输。

关于伪终端的关键点是从设备提供了一个像终端一样的界面，这使得可以将一个面向终端的程序连接到从设备，然后使用连接到主设备的另一个程序来驱动面向终端的程序。驱动程序写的输出经过终端驱动程序执行的通常的输入处理（例如，在默认模式下，回车映射为换行符），然后作为输入传递给连接到从设备的面向终端的程序。面向终端的程序写到从设备的任何东西（在执行所有通常的终端输出处理之后）都作为输入传递给驱动程序。换句话说，驱动程序正在执行在传统终端上由用户执行的功能。

伪终端用于各种应用程序，尤其是在X窗口系统登录下提供的终端窗口的实现以及在提供网络登录服务的应用程序中，如telnet和ssh。

---

/proc文件系统是一个虚拟文件系统，它以文件和目录的形式提供对内核数据结构的接口。这提供了一个简单的机制来查看和更改各种系统属性。此外，名为/proc/PID的目录集，其中PID是进程ID，允许我们查看系统上运行的每个进程的信息。

/proc文件的内容通常以便于人类阅读的文本形式存在，可以被shell脚本解析。程序只需简单地打开并从所需的文件中读取或写入。

/proc文件系统并未被任何标准规定，我们描述的细节是特定于Linux的。

---

系统调用将处理器状态从用户模式更改为内核模式，以便CPU可以访问受保护的内核内存。

系统调用的集合是固定的。每个系统调用由一个唯一的编号标识。（这种编号方案通常对程序不可见，程序通过名称标识系统调用。）

每个系统调用可能有一组参数，用于指定从用户空间（即进程的虚拟地址空间）到内核空间的信息传输，反之亦然。


1. 应用程序通过在C库中调用包装器函数来进行系统调用。
2. 包装器函数必须将所有系统调用参数提供给系统调用陷阱处理例程。这些参数通过堆栈传递给包装器，但内核期望它们在特定的寄存器中。包装器函数将参数复制到这些寄存器。
3. 由于所有的系统调用都以相同的方式进入内核，内核需要某种方法来识别系统调用。为了允许这样做，包装器函数将系统调用号复制到特定的CPU寄存器（%eax）。
4. 包装器函数执行一个陷阱机器指令（int 0x80），该指令导致处理器从用户模式切换到内核模式并执行系统的陷阱向量位置0x80（128十进制）指向的代码。
5. 更新的x86-32架构实现了sysenter指令，与传统的int 0x80陷阱指令相比，它提供了更快的进入内核模式的方法。从2.6内核和glibc 2.3.2开始支持使用sysenter。
6. 响应到位置0x80的陷阱，内核调用其system_call()例程（位于汇编文件arch/x86/kernel/entry.S中）来处理陷阱。这个处理程序：
  - 将寄存器值保存到内核堆栈
  - 检查系统调用号的有效性
  - 调用适当的系统调用服务例程，通过使用系统调用号来索引所有系统调用服务例程的表（内核变量sys_call_table）来找到它。如果系统调用服务例程有任何参数，它首先检查它们的有效性；例如，检查地址是否指向用户内存中的有效位置。然后，服务例程执行所需的任务，这可能涉及修改给定参数中指定的地址处的值，并在用户内存和内核内存之间传输数据（例如，在I/O操作中）。最后，服务例程返回结果状态给system_call()例程
  - 从内核堆栈中恢复寄存器值，并将系统调用返回值放在堆栈上
  - 返回到包装函数，同时将处理器返回到用户模式
7. 如果系统调用服务例程的返回值表示错误，包装器函数使用此值设置全局变量errno。然后，包装函数返回给调用者，提供一个整数返回值，表示系统调用的成功或失败。
8. 在Linux上，系统调用服务例程遵循返回非负值表示成功的约定。出错时，例程返回一个负数，这是errno常数之一的负值。返回负值时，C库包装函数将其取反（使其为正），将结果复制到errno中，并返回
9. 该约定依赖于系统调用服务例程在成功时不返回负值的假设。然而，对于其中的一些例程，这个假设并不成立。通常，这不是问题，因为负值的errno值的范围与有效的负返回值不重叠。然而，这个约定在一个情况下确实造成了问题：fcntl()系统调用的F_GETOWN操作，我们在第63.3节中描述

![](/images/blog/system-call-example.jpg)

在Linux/x86-32上，execve()是系统调用号11（__NR_execve）。因此，在sys_call_table向量中，条目11包含sys_execve()的地址，这是此系统调用的服务例程。（在Linux上，系统调用服务例程通常具有sys_xyz()形式的名称，其中xyz()是所讨论的系统调用。）

即使对于一个简单的系统调用，也必须做很多工作，因此系统调用有小但可感知的开销

从C程序的角度看，调用C库包装函数与调用相应的系统调用服务例程是同义的

---

库函数只是构成标准C库的众多函数之一

许多库函数不使用任何系统调用（例如，字符串操作函数）。另一方面，有些库函数是基于系统调用之上的。例如，fopen()库函数使用open()系统调用来实际打开一个文件。通常，库函数的设计目的是为了提供比底层系统调用更友好的接口。例如，printf()函数提供了输出格式化和数据缓冲，而write()系统调用仅输出一个字节块。同样地，malloc()和free()函数执行各种记账任务，使它们比底层的brk()系统调用更容易地分配和释放内存。

标准C库；GNU C库 (glibc): 在各种UNIX实现上有不同的标准C库实现。在Linux上最常用的实现是GNU C库（glibc,

某些Linux发行版中，GNU C库的路径并不是位于/lib/libc.so.6。确定库位置的一种方法是针对动态链接到glibc的可执行文件（大多数可执行文件都以这种方式链接）运行ldd（列出动态依赖）程序。然后我们可以检查生成的库依赖性列表，找到glibc共享库的位置：

```shell
$ ldd myprog | grep libc
        libc.so.6 => /lib/tls/libc.so.6 (0x4004b000)
```

---

有些系统调用永远不会失败。例如，getpid()总是成功返回进程的ID，而_exit()总是终止进程。不需要检查此类系统调用的返回值

```c
fd = open(pathname, flags, mode);      /* system call to open a file */
if (fd == -1) {
    /* Code to handle the error */
}
...

if (close(fd) == -1) {
    /* Code to handle the error */
}
```

当系统调用失败时，它会将全局整数变量errno设置为一个正值，该值识别特定的错误

```c
cnt = read(fd, buf, numbytes);
if (cnt == -1) {
    if (errno == EINTR)
        fprintf(stderr, "read被信号中断\n");
    else {
        /* 发生了其他错误 */
    }
}
```

成功的系统调用和库函数永远不会将errno重置为0，因此由于前一个调用的错误，此变量可能具有非零值。此外，SUSv3允许成功的函数调用将errno设置为非零值（尽管很少有函数这样做）。因此，在检查错误时，我们应该首先检查函数返回值是否指示出错，然后再检查errno以确定错误的原因。

少数系统调用（例如getpriority()）可以在成功时合法地返回-1。为了确定此类调用中是否发生错误，我们在调用之前将errno设置为0，然后之后检查它。如果调用返回-1且errno为非零，则发生错误。 （也适用于少数库函数的类似声明。）

系统调用失败后的常见操作是根据errno值打印错误消息。为此目的提供了perror()和strerror()库函数。

perror()函数打印其msg参数指向的字符串，然后打印与errno的当前值相对应的消息。

```c
#include <stdio.h>

void perror(const char *msg);
```

更简单的办法：
```c
fd = open(pathname, flags, mode);
if (fd == -1) {
    perror("open");
    exit(EXIT_FAILURE);
}
```

strerror() 函数返回其 errnum 参数给出的错误编号对应的错误字符串。

```c
#include <string.h>

char *strerror(int errnum);
```

返回对应于 errnum 的错误字符串的指针

由 strerror() 返回的字符串可能是静态分配的，这意味着它可能会被后续对 strerror() 的调用覆盖。

如果 errnum 指定了一个未被识别的错误编号，strerror() 返回形如 Unknown error nnn 的字符串。在一些其他的实现中，这种情况下 strerror() 返回 NULL。

由于 perror() 和 strerror() 函数是受区域设置影响的（第10.4节），错误描述是以当地语言显示的。

---

- 有些库函数以与系统调用完全相同的方式返回错误信息：返回值为 -1，errno 指示特定的错误。这样的函数的一个例子是 remove()，它删除一个文件（使用 unlink() 系统调用）或一个目录（使用 rmdir() 系统调用）。这些函数的错误可以像系统调用的错误那样被诊断。
- 有些库函数在错误时返回除 -1 以外的值，但仍然设置 errno 以指示特定的错误条件。例如，fopen() 在错误时返回一个 NULL 指针，而 errno 的设置取决于哪个底层系统调用失败了。可以使用 perror() 和 strerror() 函数来诊断这些错误。
- 其他库函数根本不使用 errno。确定错误的存在和原因的方法取决于特定的函数，并在该函数的手册页中有文档说明。对于这些函数，使用 errno、perror() 或 strerror() 来诊断错误是一个错误。

---

各种实现数据类型使用标准C类型表示，例如进程ID、用户ID和文件偏移量。虽然使用C基础类型如int和long来声明存储此类信息的变量是可能的，但这减少了UNIX系统之间的可移植性，原因如下：

- 这些基本类型的大小在UNIX实现之间是不同的（例如，一个系统上的long可能是4字节，而另一个系统上是8字节），或者在同一实现的不同编译环境中有时也是不同的。此外，不同的实现可能使用不同的类型来表示相同的信息。例如，进程ID在一个系统上可能是int，而在另一个系统上可能是long。
- 即使在单一的UNIX实现上，用于表示信息的类型也可能在实现的版本之间有所不同。在Linux上的显著例子是用户和组ID。在Linux 2.2及更早版本中，这些值用16位表示。在Linux 2.4及更高版本中，它们是32位值。

为了避免此类可移植性问题，SUSv3指定了各种标准系统数据类型，并要求实现适当地定义和使用这些类型。每种类型都使用C的typedef特性来定义。例如，pid_t数据类型用于表示进程ID，在Linux/x86-32上，这种类型的定义如下：

```c
typedef int pid_t;
```

大多数标准系统数据类型的名称都以_t结尾。其中许多在头文件`<sys/types.h>`中声明，尽管有些则在其他头文件中定义。

---

通常我们不会说Linux中每个系统数据类型实际上使用哪个特定的本地数据类型来表示，因为一个可移植的应用程序应该被编写成它不关心使用哪种数据类型

必须小心不要在printf()调用中包含表示依赖性。表示依赖性可能会发生，因为C的参数提升规则将short类型的值转换为int，但保持int和long类型的值不变。这意味着，根据系统数据类型的定义，printf()调用中传递的是int或long。然而，因为printf()在运行时无法确定其参数的类型，所以调用者必须使用%d或%ld格式说明符显式提供这些信息。问题在于，在printf()调用中简单地编码其中一个说明符会创建一个实现依赖性。通常的解决方案是使用%ld说明符，并总是将相应的值转换为long，如下所示：

```c
pid_t mypid;

mypid = getpid();           /* 返回调用进程的进程ID */
printf("我的PID是 %ld\n", (long) mypid);
```
我们对上述技术只做一个例外。因为在某些编译环境中，off_t数据类型的大小是long long，所以我们将off_t值转换为这种类型并使用%lld说明符

---

每个 UNIX 实现都指定了一系列标准结构体，这些结构体用于各种系统调用和库函数。例如，考虑 sembuf 结构体，它用于表示由 semop() 系统调用执行的信号量操作：

```c
struct sembuf {
    unsigned short sem_num;         /* 信号量编号 */
    short          sem_op;          /* 要执行的操作 */
    short          sem_flg;         /* 操作标志 */
};
```

虽然 SUSv3 指定了像 sembuf 这样的结构体，但重要的是:
- 通常情况下，这些结构体中字段定义的顺序并未指定。
- 在某些情况下，这些结构体中可能包含额外的实现特定字段。

因此，使用如下结构体初始化器是不可移植的：
```c
struct sembuf s = { 3, -1, SEM_UNDO };
```

虽然这个初始化器在 Linux 上可以工作，但在字段顺序不同的其他实现上则无法工作。要可移植地初始化这些结构体，我们必须使用明确的赋值语句，如下所示：

```c
struct sembuf s;

s.sem_num = 3;
s.sem_op = -1;
s.sem_flg = SEM_UNDO;
```

如果我们使用的是 C99，那么我们可以使用该语言为结构体初始化器提供的新语法来编写等效的初始化：

```c
struct sembuf s = { .sem_num = 3, .sem_op = -1, .sem_flg = SEM_UNDO };
```
---


某些情况下，某个宏可能不会在所有的 UNIX 实现中都被定义。例如，WCOREDUMP() 宏（它检查子进程是否生成了核心转储文件）是广泛可用的，但它没有在 SUSv3 中被指定。因此，这个宏可能不会出现在某些 UNIX 实现中。为了可移植地处理这种可能性，我们可以使用 C 预处理器 #ifdef 指令，如下例所示：

```c
#ifdef WCOREDUMP
    /* 使用 WCOREDUMP() 宏 */
#endif
```
---

系统调用允许进程从内核请求服务。即使是最简单的系统调用，与用户空间的函数调用相比，也有相当大的开销，因为系统必须暂时切换到内核模式来执行系统调用，并且内核必须验证系统调用参数，并在用户内存和内核内存之间传输数据。

标准 C 库提供了大量的库函数，可以执行广泛的任务。一些库函数使用系统调用来完成它们的工作；其他则完全在用户空间内执行任务。在 Linux 上，通常使用的标准 C 库实现是 glibc。

---



---
title: "读gRPC Microservices in Go第四章"
date: "2024-02-05"
description: "micro 4"
image: /images/blog/
authors:
  - KUD
---

![](/images/blog/Hexagonal-architecture.png)

六边形架构也被称为端口和适配器系统。使用端口和适配器创建了一个抽象层，隔离了应用程序的核心和外部依赖

虽然对于六边形架构文件夹没有书面规则，但以下文件夹在典型的Go项目中很常见：
- 应用文件夹 —— 这个文件夹包含微服务业务逻辑，它是指代业务实体的领域模型和向其他模块公开核心功能的API的组合。
- 端口文件夹 —— 这个文件夹包含核心应用程序与第三方之间集成的合同信息。这可以是关于访问核心应用功能的合同，或者关于指定数据库系统可用功能的合同（如果用于持久层）。
- 适配器文件夹 —— 这个文件夹包含使用在端口中定义的合同的具体实现。例如，gRPC可以是一个适配器，具有处理请求并使用API端口访问核心功能的具体实现，比如你有一个应用程序具有一些功能，并将其暴露给客户。功能可以是CreateProduct、GetProduct等，你可以通过REST、gRPC和其他适配器将它们暴露给客户，这些适配器将使用这些功能的端口层定义的合同。我们将在本章后面的部分回顾这个话题，并查看更高级的例子。

go mod init命令接受一个VCS URL来准备依赖结构。当你将这个模块作为另一个项目的依赖添加时，该项目将从你提供的模块初始化VCS解析可用标签

先实现应用核心，然后实现外层依赖于它们变得更加容易。例如，Web或CLI层依赖于应用层

order.go
```go
package domain

import (
    "time"
)

type OrderItem struct {
    ProductCode string  `json:"product_code"`  # 产品的唯一代码
    UnitPrice   float32 `json:"unit_price"`    # 单个产品的价格
    Quantity    int32   `json:"quantity"`      # 产品的数量
}

type Order struct {
    ID         int64       `json:"id"`         # 订单的唯一标识符
    CustomerID int64       `json:"customer_id"`# 订单的拥有者
    Status     string      `json:"status"`     # 订单的状态
    OrderItems []OrderItem `json:"order_items"`# 订单中购买的物品列表
    CreatedAt  int64       `json:"created_at"` # 订单创建时间
}

func NewOrder(customerId int64, orderItems []OrderItem) Order {  # 创建默认订单的函数
    return Order{
        CreatedAt:  time.Now().Unix(),
        Status:     "Pending",
        CustomerID: customerId,
        OrderItems: orderItems,
    }
}
```

api.go
```go
package api

import (
    "github.com/huseyinbabal/microservices/order/internal/application/core/domain"  # 订单域对象的包
    "github.com/huseyinbabal/microservices/order/internal/ports"   # DB适配器的端口
)

type Application struct {
    db ports.DBPort  # API依赖于DBPort
}

func NewApplication(db ports.DBPort) *Application {
    return &Application{
        db: db,  # 在应用初始化时传递DBPort
    }
}

func (a Application) PlaceOrder(order domain.Order) (domain.Order, error) {
    err := a.db.Save(&order)  # 通过DB端口保存订单
    if err != nil {
        return domain.Order{}, err
    }
    return order, nil
}
```


---
title: "学一点点nix打包"
date: "2023-08-25"
description: "为什么我就对这种宗教性质的东西很喜欢呢"
image: /images/blog/seishunbutayaro.jpg
authors:
  - KUD
---

nix要做的就是Reproducible builds and deployments.感觉上就和虚拟环境的包管理有点像（python那种），但是实现方式上有一定区别，同时用起来比较简单

2023-08-25看了一眼这个文章：[packaging-existing-software](https://nix.dev/tutorials/learning-journey/packaging-existing-software)

icat.nix:
```nix
{ lib
, stdenv
, fetchFromGitHub
, imlib2
, xorg
}:

stdenv.mkDerivation {
  name = "icat";

  src = fetchFromGitHub {
    owner = "atextor";
    repo = "icat";
    rev = "v0.5";
    sha256 = "0wyy2ksxp95vnh71ybj1bbmqd5ggp13x3mk37pzr99ljs9awy8ka";
  };

  buildInputs = [ imlib2 xorg.libX11.dev ];

  installPhase = ''
    mkdir -p $out/bin
    cp icat $out/bin
  '';
}
```

icat.nix:
```nix
let
  pkgs = import <nixpkgs> { };
in
{
  icat = pkgs.callPackage ./icat.nix { };
}
```
nixpkgs是一个包含大量Nix包定义的git存储库。 import &lt;nixpkgs&gt 会导入这个存储库并返回一个包含所有可用包的集合

`pkgs.callPackage`是一个在这个集合中查找和调用指定包定义的方法

hello.nix自己没有显式从nixpkgs中使用任何东西。之所以可以在nixpkgs环境中工作,是因为在调用这个打包函数时,会默认传入nixpkgs中定义的一些变量,比如stdenv, fetchzip等

---

之所以需要`{ }`,是因为Nix中的函数调用都需要以`{ attr = value; }`的形式提供参数。

即使不需要任何参数,也需要提供一个空的`{ }`,表示调用这个函数时不传入任何参数。

---

callPackage本身确实是一个函数,但其参数格式有点特殊。

在Nix中,callPackage的完整签名是: `callPackage : PkgSet -> Path -> AttrSet -> Derivation`。它接受3个参数:
1. PkgSet - 存放所有包定义的集合,通常是`import <nixpkgs>` 返回的结果。callPackage内部会自动使用这个pkgs集合,不需要我们传递。
2. Path - 指向具体包定义文件的路径,如 `./hello.nix`。
3. AttrSet - 传递给包定义函数的配置参数。
4. Derivation - 这个->在Nix的函数签名中,指向最后一个参数是返回值类型。

可以看到,尽管callPackage是一个函数调用,但其参数中既包含常规的参数(AttrSet),也包含非参数形式的参数(PkgSet和Path)。

这是因为callPackage本身就是一个特殊的接口函数,它将找到包定义文件和调用包定义函数这两个动作组合在一起了。

所以使用方式是: `pkgs.callPackage ./hello.nix { }`。而不是传统的`func(arg1, arg2)`形式。

这实际上是Nix语言一个特殊的语法点,允许某些"函数"像语言构造一样使用,让包的导入更加方便。

---

pkgs不仅仅包含nixpkgs中所有包的定义,还包含一些用于操作这些包的方法,比如callPackage。

具体来说,`import <nixpkgs>`返回的pkgs包含:
- 所有nixpkgs包的定义,以属性名访问,如pkgs.stdenv
- 一些操作包的函数,比如callPackage,buildEnv等
- 一些系统信息,如pkgs.system等

---

在 Nix 中，一个 derivation 是构建过程的描述，它指定了如何构建一个包（package）或应用程序。

可以创建一个 overlay 来添加或重写包。Overlay 是一个函数，它接受一个包集合（pkgs）作为输入，并返回一个修改后的包集合

---

在 NixOS 或使用 Nix 的 home-manager 管理环境中，xdg.configFile 是一个配置选项，用于管理遵循 XDG 基础目录规范的配置文件。这里的 xdg 代表 "XDG Base Directory Specification"。

XDG Base Directory Specification 是由 FreeDesktop.org 定义的标准，旨在规范 UNIX 类系统中用户配置文件、数据文件和缓存文件的存储位置。这个规范旨在替代传统的将所有配置文件放在用户家目录下的做法（例如，大量的点文件（dotfiles）和点目录（dot directories）），从而提供一种更有组织的方式来管理这些文件。

根据 XDG 规范，配置文件通常存放在 $HOME/.config 目录下。因此，在 home-manager 中使用 xdg.configFile 时，你可以指定在 .config 目录下的特定路径和文件内容。例如：

```nix
xdg.configFile."hypr/hyprland.conf".text = ''
  # hyprland 配置内容
  ...
'';
```

这个配置将会在用户的 .config/hypr/ 目录下创建一个名为 hyprland.conf 的文件，并填充指定的内容。

---

```nix
(pkgs.python3.withPackages (ps: with ps; [
    # ...
]))
```

`withPackages`:
- `withPackages` 是一个函数，属于 python3 对象。它的作用是创建一个包含指定 Python 包的环境。
- 这个函数接受另一个函数作为参数，这个参数函数用于定义需要包含的 Python 包。

`(ps: with ps; [ ... ])`:
- 这是传递给 `withPackages` 的函数。它的参数 ps 代表 Python 包的集合。
- `with ps`; 是一个 Nix 语言的构造，它允许在后续的表达式中直接使用 ps 中的属性，而不需要再次写 ps. 前缀。这样做的目的是为了简化代码。
- [ ... ] 是一个列表，你可以在这个列表中指定你希望包含在你的 Python 环境中的所有包。例如，ps.lxml 和 ps.requests 是 ps 集合中的两个包。

---



---
title: into dmesg
date: "2023-07-01"
description: hardware ready to boost
image: /images/blog/arima.jpg
authors:
  - KUD
---

```text
[    0.000000] microcode: microcode updated early to revision 0x113,
               date = 2023-02-06
```
微码（microcode）在启动早期已更新到修订版本 0x113，更新日期是 2023/2/6

microcode 是嵌入到 CPU 中的固件，用于控制处理器硬件操作基本逻辑。位于处理器的控制单元内部，作为指令集架构（ISA）和硬件间的中间层。主要作用是解释、执行处理器指令集中的复杂指令。

微码更新是临时的，每次系统重启时都需要重新加载，不会永久写入到硬件中。微码更新一般是修正硬件错误或增强安全性，是普通的软件更新

> Lain独有

---

```text
[    0.000000] Linux version 6.1.35 (nixbld@localhost)
              (gcc (GCC) 12.3.0, GNU ld (GNU Binutils) 2.40)
              #1-NixOS SMP PREEMPT_DYNAMIC Wed Jun 21 14:01:03 UTC 2023
```
SMP 表示“对称多处理”（Symmetric Multiprocessing）。意味内核支持多个CPU或多核CPU，允许这些处理器同时运行

内核抢占模型是决定系统在什么时候和如何暂停正在运行的任务，以运行另一个任务。这特性对OS的响应性和实时性能至关重要。Linux内核中常见的抢占模型：
- 非抢占内核（No Preemption）:
  - 一旦内核执行任务（如系统调用或内核服务），会一直运行到完成，不会被其他任务打断
  - 优先保证内核稳定性和简单性，但导致较差的系统响应，特别在高负载下
- 自愿抢占内核（Voluntary Preemption）:
  - 内核代码包含许多“抢占点”，这些点上内核会检查是否有更高优先级的任务需运行
  - 提供了抢占的可能性，但仍保持较高稳定性，因为抢占点是明确控制的
- 抢占内核（Preemptive Kernel）:
  - 内核可在几乎任何时候被更高优先级的任务打断。包括系统调用和大多数内核代码
  - 显著提高系统响应性，特别对于实时任务和多任务处理，增加内核复杂性和潜在稳定性问题
- 实时抢占（Real-Time Preemption）:
  - 可选的最高级别抢占模型，旨在为需要高度实时响应的系统（如工业控制系统）提供支持
  - 内核具有更多抢占点，且能够以更高的优先级响应实时任务

选择适当抢占模型时，需在系统响应性和稳定性间权衡。通常桌面系统和通用服务器倾向于使用某种程度的抢占以提高响应性，对于高稳定性要求的环境（如关键任务服务器），可能选择非抢占或自愿抢占模型

PREEMPT_DYNAMIC 是 Linux 内核中相对新的抢占模型配置，允许内核在运行时动态地在不同抢占模型间切换，而不是编译时固定选择一种模型。使OS能够根据工作负载和系统条件灵活调整抢占行为，以平衡响应性和稳定性

Wed Jun 21 14:01:03 UTC 2023: 是内核编译的日期时间

- TODO: 暂时不知道如何查看当前系统运行在什么抢占模型上

---

```text
[    0.000000] Command line: initrd=\efi\nixos\gp0yimmqv6r4cx1v76mznvr2xifgdnsd-initrd-linux-6.1.35-initrd.efi
               init=/nix/store/z95pb228s4cpbh07v03gshs6gza6nq9y-nixos-system-Lain-23.11.20230628.60a783e/init
               radeon.cik_support=0
               amdgpu.cik_support=1
               loglevel=4
```
内核启动时的命令行参数
- initrd(INITial Ram Disk): 指定初始 RAM 磁盘的位置
- init: 是指定初始程序的位置
- loglevel=4 是设置系统日志级别。

初始RAM磁盘是Linux系统引导过程中使用的临时文件系统，包含启动系统所需的最基本的驱动程序和工具
- 加载必要的驱动程序：Linux系统启动时，内核可能需加载驱动程序才能访问磁盘驱动器、文件系统或其他硬件。这些驱动程序可能不包含在内核中，需要initrd来提供
- 准备根文件系统：initrd在内核完全加载根文件系统之前，为系统提供临时根文件系统。临时根文件系统包含了用于初始化系统的工具和脚本。一旦系统真正根文件系统被挂载，initrd通常会被卸载并从内存中移除
- 应对复杂硬件配置：如RAID或LVM，可能需要额外软件来正确识别和配置。initrd允许这些工具在系统引导的早期阶段可用，确保硬件被正确设置

initrd是一个物理磁盘分区的映像，通常作为单独文件存储。被装载为一个内存驻留的块设备。由于initrd基于磁盘映像，它在大小和灵活性方面有一定限制

initramfs是initrd的现代替代，并不基于磁盘映像，而是cpio归档（基于UNIX的归档格式），引导过程中直接被内核解压到一个内存中的文件系统。可动态调整大小，且可在运行时更容易地修改。还允许系统在不重启情况下更改根文件系统

实际使用中即使系统实际上使用initramfs，dmesg输出或其他系统文档中仍可能将其称为initrd

---

```text
[    0.000000] x86/split lock detection:
               #AC: crashing the kernel on kernel split_locks and warning on user-space split_locks
```
当内核发生分裂锁定（split lock）时，系统将会崩溃，而在用户空间发生分裂锁定时会发出警告

内核的分裂锁定（Split Lock）是与处理器和内存访问相关的概念，主要涉及多线程编程和并发控制

处理器缓存以“缓存行”为单位工作，通常大小为64字节。处理器读取或写入数据时会加载整个缓存行到缓存中

多线程编程中锁是一种机制，控制多个线程对共享资源（如内存）的访问。当一个线程获取锁时，其他线程必须等待直到锁被释放

当一个锁的数据结构横跨多个缓存行时，会发生分裂锁定。如锁定的数据结构开始于一个缓存行的末尾并延伸到下一个缓存行，处理器必须锁定两个缓存行来保证原子性。这增加了内存总线的负担，因为处理器必须同时锁定和同步两个缓存行，而不是一个

分裂锁定会导致显著性能下降，处理器需更多时间管理和同步两个缓存行。它会增加内存总线的负载和延迟。某些情况下可能导致系统稳定性问题，特别在高并发环境中

编程时应确保锁的数据结构不会跨越多个缓存行。使用对齐技术确保数据结构在单个缓存行内。一些现代处理器提供了避免或减轻分裂锁定影响的机制。如Intel的一些处理器有选项来检测和阻止分裂锁定操作

> Lain独有

---

```text
[    0.000000] x86/fpu: Supporting XSAVE feature 0x001:
                        'x87 floating point registers'
[    0.000000] x86/fpu: Supporting XSAVE feature 0x002:
                        'SSE registers'
[    0.000000] x86/fpu: Supporting XSAVE feature 0x004:
                        'AVX registers'
[    0.000000] x86/fpu: Supporting XSAVE feature 0x200:
                        'Protection Keys User registers'
[    0.000000] x86/fpu: xstate_offset[2]:  576, xstate_sizes[2]:  256
[    0.000000] x86/fpu: xstate_offset[9]:  832, xstate_sizes[9]:    8
[    0.000000] x86/fpu: Enabled xstate features 0x207, context size is 840 bytes,
                        using 'compacted' format.
```
x86 浮点单元（FPU）配置信息。表明支持 XSAVE 特性，以及这些特性对应状态偏移和大小。启用了 xstate features 0x207，上下文大小 840 字节，使用了'compacted'格式。这段信息说明了处理器支持保存和恢复一组扩展的浮点和SIMD状态（如x87 FPU, SSE, AVX等），需要840字节的空间来存储这些状态，并且它使用一种优化的方式来压缩这些状态信息

FPU 的 XSAVE 特性用于保存和恢复处理器的浮点和 SIMD（单指令多数据）状态。这特性在进行上下文切换或处理多线程应用时非常重要

FPU负责处理浮点计算，而SIMD（如Intel的SSE和AVX指令集）用于加速多媒体、科学计算和大数据处理中的并行计算。这些操作涉及到一系列寄存器，包括传统的FPU寄存器和新的SIMD寄存器

在进行频繁线程或进程切换时，XSAVE确保寄存器状态的正确保存和恢复，维持应用程序正确执行


> Lain独有

---

```text
[    0.000000] signal: max sigframe size: 3632
```
信号栈帧（sigframe）的最大尺寸是 3632 字节。信号栈帧是OS用于处理进程接收信号时保存和恢复上下文的数据结构

当进程收到信号时，OS会在进程的堆栈上创建信号栈帧。包含处理信号所需信息，以及处理完信号后恢复到进程原始状态的必要信息

> Mikan也有，但是在0.198207才加载这个，同时大小为3376字节

---

```text
[    0.000000] BIOS-provided physical RAM map:
```
内存映射信息是由 BIOS 提供

```text
[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009dfff] usable
[    0.000000] BIOS-e820: [mem 0x000000000009e000-0x000000000009efff] reserved
[    0.000000] BIOS-e820: [mem 0x000000000009f000-0x000000000009ffff] usable
[    0.000000] BIOS-e820: [mem 0x00000000000a0000-0x00000000000fffff] reserved
[    0.000000] BIOS-e820: [mem 0x0000000000100000-0x0000000064840fff] usable
[    0.000000] BIOS-e820: [mem 0x0000000064841000-0x0000000064841fff] reserved
[    0.000000] BIOS-e820: [mem 0x0000000064842000-0x000000006589bfff] usable
[    0.000000] BIOS-e820: [mem 0x000000006589c000-0x000000006589cfff] reserved
[    0.000000] BIOS-e820: [mem 0x000000006589d000-0x00000000705aafff] usable
[    0.000000] BIOS-e820: [mem 0x00000000705ab000-0x00000000742aafff] reserved
[    0.000000] BIOS-e820: [mem 0x00000000742ab000-0x000000007451efff] ACPI data
[    0.000000] BIOS-e820: [mem 0x000000007451f000-0x000000007471efff] ACPI NVS
[    0.000000] BIOS-e820: [mem 0x000000007471f000-0x0000000075ffefff] reserved
[    0.000000] BIOS-e820: [mem 0x0000000075fff000-0x0000000075ffffff] usable
[    0.000000] BIOS-e820: [mem 0x0000000076000000-0x0000000079ffffff] reserved
[    0.000000] BIOS-e820: [mem 0x000000007a400000-0x000000007a7fffff] reserved
[    0.000000] BIOS-e820: [mem 0x000000007b000000-0x00000000807fffff] reserved
[    0.000000] BIOS-e820: [mem 0x00000000c0000000-0x00000000cfffffff] reserved
[    0.000000] BIOS-e820: [mem 0x00000000fe000000-0x00000000fe010fff] reserved
[    0.000000] BIOS-e820: [mem 0x00000000fec00000-0x00000000fec00fff] reserved
[    0.000000] BIOS-e820: [mem 0x00000000fed00000-0x00000000fed00fff] reserved
[    0.000000] BIOS-e820: [mem 0x00000000fed20000-0x00000000fed7ffff] reserved
[    0.000000] BIOS-e820: [mem 0x00000000fee00000-0x00000000fee00fff] reserved
[    0.000000] BIOS-e820: [mem 0x00000000ff000000-0x00000000ffffffff] reserved
[    0.000000] BIOS-e820: [mem 0x0000000100000000-0x000000087f7fffff] usable
```
BIOS 提供的物理 RAM 内存映射，表明内存地址的范围和用途。被OS用来管理内存资源
- usable 可被OS使用
- reserved 被保留不能被OS使用(如BIOS保留区域)
- ACPI data 被 ACPI 系统使用
- ACPI NVS 被 ACPI 系统用作非易失性存储

> 当然与Mikan的内存映射不一样

---

```text
[    0.000000] NX (Execute Disable) protection: active
```
系统启用了无执行（NX）保护，这是一种硬件技术，可以防止恶意软件通过数据区域执行代码。

NX（Non-eXecutable），也称执行禁止（Execute Disable）用于标记内存中某些区域为不可执行。这些内存区域不能被用来执行代码，只能用于存储数据。用于防御各种恶意攻击如缓冲区溢出攻击

支持NX的系统中，OS和处理器共同管理内存页面（通常是内存基本单位）的权限。每个内存页面可被标记为可执行或非可执行
- 缓冲区溢出攻击：攻击者无法通过溢出数据缓冲区来注入恶意代码并执行，因为数据缓冲区所在内存通常被标记NX
- 返回指向栈的编程（Return-to-Stack）攻击：由于栈被标记为NX，攻击者无法执行栈上代码
- 返回指向libc的编程（Return-to-libc）攻击：这类攻击通过跳转到标准库中的函数来绕过NX保护，但对于防止直接在非可执行内存上执行代码仍有效

Intelx86和x86_64架构中的XD位，AMD处理器中的NX位提供硬件支持区分可执行和非可执行的内存页面

---

```text
[    0.000000] APIC: Static calls initialized
```
内核在启动过程中完成了与APIC相关的某些静态调用的初始化

高级可编程中断控制器（APIC）是用于管理中断的硬件组件。APIC主要负责接收、优先级排序和将中断发送到CPU进行处理。多核处理器系统中APIC还负责协调哪个CPU核心处理特定中断
- 中断是硬件设备通知CPU需处理某事件（如鼠标移动、键盘输入、网络数据到达等）的机制

这里静态调用通常指内核为高效管理中断而建立的一些预定义函数调用或例程。这些调用在系统启动时被初始化，以便在处理中断时能快速响应。初始化过程包括设置静态调用地址、参数和相关的中断处理逻辑

---

```text
[    0.000000] e820: update [mem 0x5e181018-0x5e19ee57] usable ==> usable
[    0.000000] e820: update [mem 0x5e181018-0x5e19ee57] usable ==> usable
[    0.000000] e820: update [mem 0x5e171018-0x5e180057] usable ==> usable
[    0.000000] e820: update [mem 0x5e171018-0x5e180057] usable ==> usable
```
系统启动过程中，内存的状态被重新确认或更新

```text
[    0.000000] extended physical RAM map:
```
内存映射信息是扩展的物理 RAM 映射

```text
[0.000000] reserve setup_data: [mem 0x0000000000000000-0x000000000009dfff] usable
[0.000000] reserve setup_data: [mem 0x000000000009e000-0x000000000009efff] reserved
[0.000000] reserve setup_data: [mem 0x000000000009f000-0x000000000009ffff] usable
[0.000000] reserve setup_data: [mem 0x00000000000a0000-0x00000000000fffff] reserved
[0.000000] reserve setup_data: [mem 0x0000000000100000-0x000000005e171017] usable
[0.000000] reserve setup_data: [mem 0x000000005e171018-0x000000005e180057] usable
[0.000000] reserve setup_data: [mem 0x000000005e180058-0x000000005e181017] usable
[0.000000] reserve setup_data: [mem 0x000000005e181018-0x000000005e19ee57] usable
[0.000000] reserve setup_data: [mem 0x000000005e19ee58-0x0000000064840fff] usable
[0.000000] reserve setup_data: [mem 0x0000000064841000-0x0000000064841fff] reserved
[0.000000] reserve setup_data: [mem 0x0000000064842000-0x000000006589bfff] usable
[0.000000] reserve setup_data: [mem 0x000000006589c000-0x000000006589cfff] reserved
[0.000000] reserve setup_data: [mem 0x000000006589d000-0x00000000705aafff] usable
[0.000000] reserve setup_data: [mem 0x00000000705ab000-0x00000000742aafff] reserved
[0.000000] reserve setup_data: [mem 0x00000000742ab000-0x000000007451efff] ACPI data
[0.000000] reserve setup_data: [mem 0x000000007451f000-0x000000007471efff] ACPI NVS
[0.000000] reserve setup_data: [mem 0x000000007471f000-0x0000000075ffefff] reserved
[0.000000] reserve setup_data: [mem 0x0000000075fff000-0x0000000075ffffff] usable
[0.000000] reserve setup_data: [mem 0x0000000076000000-0x0000000079ffffff] reserved
[0.000000] reserve setup_data: [mem 0x000000007a400000-0x000000007a7fffff] reserved
[0.000000] reserve setup_data: [mem 0x000000007b000000-0x00000000807fffff] reserved
[0.000000] reserve setup_data: [mem 0x00000000c0000000-0x00000000cfffffff] reserved
[0.000000] reserve setup_data: [mem 0x00000000fe000000-0x00000000fe010fff] reserved
[0.000000] reserve setup_data: [mem 0x00000000fec00000-0x00000000fec00fff] reserved
[0.000000] reserve setup_data: [mem 0x00000000fed00000-0x00000000fed00fff] reserved
[0.000000] reserve setup_data: [mem 0x00000000fed20000-0x00000000fed7ffff] reserved
[0.000000] reserve setup_data: [mem 0x00000000fee00000-0x00000000fee00fff] reserved
[0.000000] reserve setup_data: [mem 0x00000000ff000000-0x00000000ffffffff] reserved
[0.000000] reserve setup_data: [mem 0x0000000100000000-0x000000087f7fffff] usable
```

基于BIOS-provided Physical RAM Map提供信息，还包括OS的额外检测和配置，如特定硬件设备或驱动程序要求的内存区域，或OS基于其自身策略设定的内存区域

支持更复杂的内存管理策略，如NUMA（非统一内存访问）、内存热添加功能或特殊用途内存配置

> 我能看到上面更新的内存状态现在出现在了extended physical RAM map里面，虽然状态一直都是usable，或许之后要用到，其他没有任何改变

---

```text
[    0.000000] efi: EFI v2.80 by American Megatrends
```
使用了 EFI 引导方式，版本 2.80，由 American Megatrends 公司提供

> Mikan用的是INSYDE Corp.提供的efi，基于同一标准（如UEFI 2.8），但在具体实现、功能和用户界面上可能有所不同

```text
[    0.000000] efi: ACPI=0x7451e000 ACPI 2.0=0x7451e014 TPMFinalLog=0x7464c000
               SMBIOS=0x75d1d000 SMBIOS 3.0=0x75d1c000 MEMATTR=0x6db3b418 ESRT=0x6dcd4918
               RNG=0x74479f18 INITRD=0x600ec698 TPMEventLog=0x5e19f018
```
EFI 固件提供的各种表格和信息的地址
- ACPI=0x7451e000: ACPI 表的基地址是 0x7451e000
- SMBIOS=0x75d1d000: SMBIOS 表的基地址是 0x75d1d000

```text
[    0.000000] random: crng init done
```
系统的加密随机数生成器（Cryptographically Secure Pseudo-Random Number Generator，crng）已完成初始化。

```text
[    0.000000] SMBIOS 3.4.0 present.
```
系统的 SMBIOS（System Management BIOS，系统管理 BIOS）版本为 3.4.0。

```text
[    0.000000] DMI: ASUS System Product Name/ROG STRIX B660-I GAMING WIFI,
                    BIOS 2212 12/13/2022
```
提供了系统的 DMI（Desktop Management Interface，桌面管理接口）信息，包括制造商（ASUS）、产品名（System Product Name）、主板型号（ROG STRIX B660-I GAMING WIFI）以及 BIOS 的版本（2212）和发布日期（2022 年 12 月 13 日）

```text
[    0.000000] tsc: Detected 3500.000 MHz processor
[    0.000000] tsc: Detected 3494.400 MHz TSC
```
TSC（Time Stamp Counter，时间戳计数器）检测到处理器的频率。

```text
[    0.000129] e820: update [mem 0x00000000-0x00000fff] usable ==> reserved
[    0.000130] e820: remove [mem 0x000a0000-0x000fffff] usable
[    0.000136] last_pfn = 0x87f800 max_arch_pfn = 0x400000000
[    0.000247] x86/PAT: Configuration [0-7]: WB  WC  UC- UC  WB  WP  UC- WT
[    0.000802] e820: update [mem 0x7c000000-0xffffffff] usable ==> reserved
[    0.000806] last_pfn = 0x76000 max_arch_pfn = 0x400000000
```
关于系统内存配置的更新。内存地址从 0x00000000 到 0x00000fff 的状态从可用（usable）更改为保留（reserved）

```text
[    0.004873] esrt: Reserving ESRT space from 0x000000006dcd4918 to 0x000000006dcd49f0.
```
ESRT（EFI System Resource Table，EFI 系统资源表）空间已被保留。

```text
[    0.004876] e820: update [mem 0x6dcd4000-0x6dcd4fff] usable ==> reserved
```

```text
[    0.004888] Using GB pages for direct mapping
```
系统采用了 GB 级别的页面来进行直接映射。

```text
[0.004889] Incomplete global flushes, disabling PCID
[0.005132] Secure boot disabled
```
系统的安全启动（Secure Boot）功能已被禁用。

```text
[0.005133] RAMDISK: [mem 0x58d0e000-0x5b486fff]
```
创建了一个 RAM 磁盘（RAMDISK），也就是一部分 RAM 被模拟成硬盘使用，这部分 RAM 的地址范围是 0x58d0e000-0x5b486fff。

```text
[0.005136] ACPI: Early table checksum verification disabled
```
系统禁用了早期 ACPI 表校验和验证

```text
[0.005137] ACPI: RSDP 0x000000007451E014 000024 (v02 ALASKA)
[0.005140] ACPI: XSDT 0x000000007451D728 000114 (v01 ALASKA A M I    01072009 AMI  01000013)
[0.005144] ACPI: FACP 0x000000007451B000 000114 (v06 ALASKA A M I    01072009 AMI  01000013)
[0.005147] ACPI: DSDT 0x000000007448F000 08BFEC (v02 ALASKA A M I    01072009 INTL 20200717)
[0.005149] ACPI: FACS 0x000000007471E000 000040
[0.005151] ACPI: MCFG 0x000000007451C000 00003C (v01 ALASKA A M I    01072009 MSFT 00000097)
[0.005152] ACPI: FIDT 0x000000007448E000 00009C (v01 ALASKA A M I    01072009 AMI  00010013)
[0.005154] ACPI: SSDT 0x000000007448C000 00038C (v02 PmaxDv Pmax_Dev 00000001 INTL 20200717)
[0.005156] ACPI: SSDT 0x0000000074486000 005D34 (v02 CpuRef CpuSsdt  00003000 INTL 20200717)
[0.005157] ACPI: SSDT 0x0000000074483000 002935 (v02 SaSsdt SaSsdt   00003000 INTL 20200717)
[0.005159] ACPI: SSDT 0x000000007447F000 003339 (v02 INTEL  IgfxSsdt 00003000 INTL 20200717)
[0.005161] ACPI: HPET 0x000000007447E000 000038 (v01 ALASKA A M I    01072009 AMI  01000013)
[0.005162] ACPI: APIC 0x000000007447D000 0001DC (v05 ALASKA A M I    01072009 AMI  01000013)
[0.005164] ACPI: MCFG 0x000000007447C000 00003C (v01 ALASKA A M I    01072009 AMI  01000013)
[0.005165] ACPI: SSDT 0x000000007447A000 001F1A (v02 ALASKA Ther_Rvp 00001000 INTL 20200717)
[0.005167] ACPI: NHLT 0x0000000074478000 00002D (v00 ALASKA A M I    01072009 AMI  01000013)
[0.005168] ACPI: LPIT 0x0000000074477000 0000CC (v01 ALASKA A M I    01072009 AMI  01000013)
[0.005170] ACPI: SSDT 0x0000000074473000 002357 (v02 ALASKA TbtTypeC 00000000 INTL 20200717)
[0.005172] ACPI: SSDT 0x0000000074470000 002A83 (v02 ALASKA PtidDevc 00001000 INTL 20200717)
[0.005173] ACPI: DBGP 0x000000007446F000 000034 (v01 ALASKA A M I    01072009 AMI  01000013)
[0.005175] ACPI: DBG2 0x000000007446E000 000054 (v00 ALASKA A M I    01072009 AMI  01000013)
[0.005176] ACPI: SSDT 0x000000007446D000 000C1F (v02 ALASKA UsbCTabl 00001000 INTL 20200717)
[0.005178] ACPI: DMAR 0x000000007446C000 000050 (v02 INTEL  EDK2     00000002      01000013)
[0.005179] ACPI: FPDT 0x000000007446B000 000044 (v01 ALASKA A M I    01072009 AMI  01000013)
[0.005181] ACPI: SSDT 0x0000000074469000 001DA0 (v02 INTEL  xh_adls3 00000000 INTL 20200717)
[0.005183] ACPI: SSDT 0x0000000074465000 003AEA (v02 SocGpe SocGpe   00003000 INTL 20200717)
[0.005184] ACPI: SSDT 0x0000000074461000 0039DA (v02 SocCmn SocCmn   00003000 INTL 20200717)
[0.005186] ACPI: SSDT 0x0000000074460000 000144 (v02 Intel  ADebTabl 00001000 INTL 20200717)
[0.005187] ACPI: VFCT 0x0000000074455000 00AC84 (v01 ALASKA A M I    00000001 AMD  31504F47)
[0.005189] ACPI: BGRT 0x0000000074454000 000038 (v01 ALASKA A M I    01072009 AMI  00010013)
[0.005191] ACPI: WPBT 0x000000007432B000 000040 (v01 ALASKA A M I    00000001 ASUS 00000001)
[0.005192] ACPI: TPM2 0x000000007432A000 00004C (v04 ALASKA A M I    00000001 AMI  00000000)
[0.005194] ACPI: PHAT 0x0000000074329000 0005F1 (v01 ALASKA A M I    00000005 MSFT 0100000D)
[0.005196] ACPI: WSMT 0x0000000074476000 000028 (v01 ALASKA A M I    01072009 AMI  00010013)
```
每一个 ACPI: 后的大写字母组合代表了一种特定的 ACPI 表，例如 RSDP、XSDT、FACP、DSDT 等，这些都是 ACPI 规范中定义的不同类型的表。每种表包含了特定的系统配置信息，例如硬件设备的信息、电源管理策略等。

每个表都有一个内存地址，如 0x000000007451E014，后面的一串数字（如 000024）是表的大小，v02 代表版本，然后是表的供应商，供应商版本和日期。

在这些日志中，您可以看到很多 SSDT 表，这是系统描述表（Secondary System Descriptor Table，SSDT），用于存放 ACPI 设备的定义。

```text
[0.005197] ACPI: Reserving FACP table memory at [mem 0x7451b000-0x7451b113]
[0.005198] ACPI: Reserving DSDT table memory at [mem 0x7448f000-0x7451afeb]
[0.005198] ACPI: Reserving FACS table memory at [mem 0x7471e000-0x7471e03f]
[0.005199] ACPI: Reserving MCFG table memory at [mem 0x7451c000-0x7451c03b]
[0.005199] ACPI: Reserving FIDT table memory at [mem 0x7448e000-0x7448e09b]
[0.005200] ACPI: Reserving SSDT table memory at [mem 0x7448c000-0x7448c38b]
[0.005200] ACPI: Reserving SSDT table memory at [mem 0x74486000-0x7448bd33]
[0.005200] ACPI: Reserving SSDT table memory at [mem 0x74483000-0x74485934]
[0.005201] ACPI: Reserving SSDT table memory at [mem 0x7447f000-0x74482338]
[0.005201] ACPI: Reserving HPET table memory at [mem 0x7447e000-0x7447e037]
[0.005202] ACPI: Reserving APIC table memory at [mem 0x7447d000-0x7447d1db]
[0.005202] ACPI: Reserving MCFG table memory at [mem 0x7447c000-0x7447c03b]
[0.005203] ACPI: Reserving SSDT table memory at [mem 0x7447a000-0x7447bf19]
[0.005203] ACPI: Reserving NHLT table memory at [mem 0x74478000-0x7447802c]
[0.005204] ACPI: Reserving LPIT table memory at [mem 0x74477000-0x744770cb]
[0.005204] ACPI: Reserving SSDT table memory at [mem 0x74473000-0x74475356]
[0.005204] ACPI: Reserving SSDT table memory at [mem 0x74470000-0x74472a82]
[0.005205] ACPI: Reserving DBGP table memory at [mem 0x7446f000-0x7446f033]
[0.005205] ACPI: Reserving DBG2 table memory at [mem 0x7446e000-0x7446e053]
[0.005206] ACPI: Reserving SSDT table memory at [mem 0x7446d000-0x7446dc1e]
[0.005206] ACPI: Reserving DMAR table memory at [mem 0x7446c000-0x7446c04f]
[0.005207] ACPI: Reserving FPDT table memory at [mem 0x7446b000-0x7446b043]
[0.005207] ACPI: Reserving SSDT table memory at [mem 0x74469000-0x7446ad9f]
[0.005208] ACPI: Reserving SSDT table memory at [mem 0x74465000-0x74468ae9]
[0.005208] ACPI: Reserving SSDT table memory at [mem 0x74461000-0x744649d9]
[0.005209] ACPI: Reserving SSDT table memory at [mem 0x74460000-0x74460143]
[0.005209] ACPI: Reserving VFCT table memory at [mem 0x74455000-0x7445fc83]
[0.005209] ACPI: Reserving BGRT table memory at [mem 0x74454000-0x74454037]
[0.005210] ACPI: Reserving WPBT table memory at [mem 0x7432b000-0x7432b03f]
[0.005210] ACPI: Reserving TPM2 table memory at [mem 0x7432a000-0x7432a04b]
[0.005211] ACPI: Reserving PHAT table memory at [mem 0x74329000-0x743295f0]
[0.005211] ACPI: Reserving WSMT table memory at [mem 0x74476000-0x74476027]
```
为 ACPI（高级配置和电源接口）的各种表预留内存的信息。每个 "Reserving" 后面的表名就是 ACPI 的表名，"at [mem xxx-xxx]" 部分则指示了该表在物理内存中的位置。

例如，ACPI: Reserving FACP table memory at [mem 0x7451b000-0x7451b113] 这行表示系统为 FACP（固定 ACPI 描述表，用于电源管理）预留了位于物理内存 0x7451b000-0x7451b113 的空间。

```text
[0.005374] No NUMA configuration found
```
系统没有找到 NUMA（Non-Uniform Memory Access）配置。NUMA 是一种用于多处理器系统的内存设计，使得每个处理器都有自己的本地内存。

```text
[0.005374] Faking a node at [mem 0x0000000000000000-0x000000087f7fffff]
```
系统正在模拟一个内存节点，其地址范围从 0x0000000000000000 到 0x000000087f7fffff。

```text
[0.005376] NODE_DATA(0) allocated [mem 0x87f7fa000-0x87f7fffff]
```
系统为节点 0 分配了一块内存用于存放节点的数据。

```text
[0.005401] Zone ranges:
[0.005402]   DMA      [mem 0x0000000000001000-0x0000000000ffffff]
[0.005402]   DMA32    [mem 0x0000000001000000-0x00000000ffffffff]
[0.005403]   Normal   [mem 0x0000000100000000-0x000000087f7fffff]
[0.005404]   Device   empty
[0.005404] Movable zone start for each node
```
系统中不同内存区域的范围。这些区域包括 DMA、DMA32、Normal 和 Device。例如，Normal 区域的范围是 [mem 0x0000000100000000-0x000000087f7fffff]。

```text
[0.005405] Early memory node ranges
[0.005405]   node   0: [mem 0x0000000000001000-0x000000000009dfff]
[0.005406]   node   0: [mem 0x000000000009f000-0x000000000009ffff]
[0.005406]   node   0: [mem 0x0000000000100000-0x0000000064840fff]
[0.005407]   node   0: [mem 0x0000000064842000-0x000000006589bfff]
[0.005407]   node   0: [mem 0x000000006589d000-0x00000000705aafff]
[0.005407]   node   0: [mem 0x0000000075fff000-0x0000000075ffffff]
[0.005408]   node   0: [mem 0x0000000100000000-0x000000087f7fffff]
```
系统早期阶段，节点 0 的内存范围。例如，其中一个范围是 [mem 0x0000000000100000-0x0000000064840fff]。

```text
[0.005409] Initmem setup node 0 [mem 0x0000000000001000-0x000000087f7fffff]
[0.005412] On node 0, zone DMA: 1 pages in unavailable ranges
[0.005412] On node 0, zone DMA: 1 pages in unavailable ranges
[0.005425] On node 0, zone DMA: 96 pages in unavailable ranges
[0.006790] On node 0, zone DMA32: 1 pages in unavailable ranges
[0.006975] On node 0, zone DMA32: 1 pages in unavailable ranges
[0.007110] On node 0, zone DMA32: 23124 pages in unavailable ranges
[0.039102] On node 0, zone Normal: 8192 pages in unavailable ranges
[0.039115] On node 0, zone Normal: 2048 pages in unavailable ranges
```
在节点 0 的特定区域（xxx）中，有 yyy 页内存是无法使用的。

---
title: "读Designing Data-Intensive Applications Chapter 2"
date: "2023-11-24"
description: "backend bible?"
image: /images/blog/taxi-jks.jpg
authors:
  - KUD
---

埃德加·科德（Edgar Codd）在1970年提出的关系模型的SQL模型：数据被组织成关系（在SQL中称为表），其中每个关系是一个无序的元组（SQL中的行）集合

大多数应用程序开发使用面向对象的编程语言，导致了对SQL数据模型的常见批评：如果数据存储在关系表中，则需要在应用程序代码中的对象与数据库中的表、行和列的模型之间有一个尴尬的转换层。这种模型之间的不连贯被称为impedance mismatch

对象关系映射（ORM）框架减少了转换层所需的样板代码量，但它们无法完全隐藏两种模型之间的差异

一些开发者认为JSON模型减少了应用程序代码与存储层之间的阻抗不匹配。然而JSON作为数据编码格式存在问题。缺乏schema通常被认为是一个优势

JSON表示与图2-1中的多表模式相比具有更好的局部性。如果你想在关系示例中获取一个简历，你需要执行多个查询（通过user_id查询每个表）或执行一个混乱的多方式连接，连接users表及其下属表。在JSON表示中，所有相关信息都在一个地方，一个查询就足够了。

用户简历与用户的职位、教育历史和联系信息之间的一对多关系意味着数据中存在树状结构，JSON表示使这种树状结构明确化

---

**many to one / many to many** relationship

存储ID还是文本字符串? 使用ID时，对人类有意义的信息只存储在一个地方，所有引用它的内容都使用ID（ID只在数据库内有意义）; 直接存储文本时则在每个使用它的记录中复制了对人类有意义的信息

ID的优势在于由于它对人类没有意义，因此永远不需要更改：即使它标识的信息发生变化，ID也可以保持不变。任何对人类有意义的信息可能在将来某个时候需要更改。这会带来写入开销且存在不一致性风险。消除这种复制是数据库规范化背后的关键思想。

多对一关系不适合文档模型。关系型数据库中通过ID引用其他表中的行是正常的，因为连接很容易。文档型数据库中，对于一对多的树结构不需要连接，且连接支持通常较弱

如果数据库本身不支持连接，你必须通过对数据库进行多次查询在应用程序代码中模拟连接。（在这种情况下，地区和行业列表可能足够小且变化缓慢，应用程序可以简单地将它们保留在内存中。但尽管如此，进行连接的工作从数据库转移到应用程序代码。）

即使应用程序的初始版本很适合无连接的文档模型，随着应用程序添加功能，数据倾向于变得更加互联

---

虽然在关系型数据库中经常使用多对多关系和连接，但文档型数据库和NoSQL重新开启了关于如何在数据库中最好地表示这类关系的辩论。这场辩论比NoSQL更为古老——实际上，它可以追溯到最早的计算机化数据库系统。

20世纪70年代用于商业数据处理的最受欢迎的数据库是IBM的信息管理系统（IMS），最初为阿波罗太空计划的库存管理开发，并于1968年首次商业发布。它至今仍在使用和维护，运行在IBM的OS/390大型机上。

IMS的设计采用了一种相当简单的数据模型，称为层次模型，与文档型数据库使用的JSON模型有一些显著的相似之处。它将所有数据表示为嵌套在记录中的记录树，很像图2-2中的JSON结构。

像文档型数据库一样，IMS很适合一对多关系，但它使多对多关系变得困难，并且不支持连接。开发者必须决定是复制（非规范化）数据还是手动解析从一个记录到另一个记录的引用。20世纪60年代和70年代的这些问题与今天开发者在文档型数据库中遇到的问题非常相似。

为了解决层次模型的局限性，提出了各种解决方案。两个最突出的是关系模型（后来成为SQL，占据了世界）和网络模型（最初有很大的追随者，但最终淡出了视线）。这两个阵营之间的“大辩论”持续了整个20世纪70年代。

### 网络模型

网络模型由一个名为数据系统语言会议（CODASYL）的委员会标准化，并由几个不同的数据库供应商实现；它也被称为CODASYL模型。

CODASYL模型是层次模型的泛化。在层次模型的树结构中，每个记录都有一个父记录；在网络模型中，一个记录可以有多个父记录。例如，可以有一个代表“大西雅图地区”的记录，每个住在该地区的用户都可以与之链接。这允许建模多对一和多对多关系。

网络模型中记录之间的链接不是外键，而更像编程语言中的指针（同时存储在磁盘上）。访问记录的唯一方式是沿着这些链接链从根记录开始跟随路径。这被称为访问路径。

在最简单的情况下，访问路径可以像遍历链表一样：从链表头开始，一次查看一个记录，直到找到你想要的记录。但在多对多关系的世界中，有几条不同的路径可以通往同一记录，使用网络模型的程序员必须在头脑中跟踪这些不同的访问路径。

在CODASYL中，查询是通过在数据库中移动一个光标来执行的，通过迭代记录列表和跟随访问路径。如果一个记录有多个父记录（即，来自其他记录的多个传入指针），应用程序代码必须跟踪所有不同的关系。即使是CODASYL委员会成员也承认，这就像在n维数据空间中导航。

虽然手动选择访问路径能够最有效地利用20世纪70年代非常有限的硬件能力（如磁带驱动器，其寻道非常慢），但问题在于它们使查询和更新数据库的代码变得复杂和僵化。无论是层次模型还是网络模型，如果你没有通往所需数据的路径，你就会陷入困境。你可以更改访问路径，但那么你必须通过大量的手写数据库查询代码，并重写它以处理新的访问路径。更改应用程序的数据模型很困难。

### 关系模型

关系模型做的是将所有数据公开放置：关系（表）仅仅是元组（行）的集合。没有错综复杂的嵌套结构，没有复杂的访问路径需要遵循，如果你想查看数据。你可以读取表中的任何行或所有行，选择那些符合任意条件的行。你可以通过指定某些列作为键并匹配这些键来读取特定的行。你可以在不担心与其他表的外键关系的情况下，将新行插入任何表中。

在关系型数据库中，查询优化器自动决定以哪种顺序执行查询的哪些部分，以及使用哪些索引。这些选择实际上是“访问路径”，但重要的区别在于它们是由查询优化器自动做出的，而不是由应用程序开发人员做出的，所以我们很少需要考虑它们。

如果你想以新的方式查询你的数据，你可以简单地声明一个新的索引，查询将自动使用最合适的索引。你不需要更改你的查询来利用新索引。（另见“数据的查询语言”。）因此，关系模型使为应用程序添加新功能变得更容易。

关系型数据库的查询优化器是复杂的野兽，它们消耗了多年的研究和开发工作。但关系模型的一个关键洞见是：你只需要构建一次查询优化器，然后使用数据库的所有应用程序都可以从中受益。如果你没有查询优化器，为特定查询手动编写访问路径比编写通用优化器要容易——但从长远来看，通用解决方案会赢。

### 与文档型数据库的比较

文档型数据库在一个方面回归到了层次模型：将嵌套记录（图2-1中的一对多关系，如职位、教育和联系信息）存储在其父记录中，而不是在单独的表中。

然而，当涉及到表示多对一和多对多关系时，关系型和文档型数据库并没有根本的不同：在两种情况下，相关项目都是通过唯一标识符引用的，这在关系模型中称为外键，在文档模型中称为文档引用。这个标识符在读取时通过使用连接或后续查询来解析。到目前为止，文档型数据库还没有走上CODASYL的道路。

---

支持文档数据模型的主要论点是模式灵活性、由于局部性而带来的更好性能，以及对于某些应用来说，它更接近应用所使用的数据结构。而关系模型则通过提供更好的连接支持、多对一和多对多关系来进行反驳。

文档模型有局限性：例如，你不能直接引用文档中的嵌套项，而需要说类似于“用户251的职位列表中的第二项”（类似于层次模型中的访问路径）。然而，只要文档不是太深层次嵌套，这通常不是问题。

文档型数据库对连接的支持较差可能是一个问题，也可能不是问题，这取决于应用。例如，在使用文档型数据库记录何时发生哪些事件的分析应用中，可能永远不需要多对多关系。

然而，如果你的应用确实使用了多对多关系，文档模型就变得不那么吸引人。可以通过非规范化来减少对连接的需求，但应用程序代码需要做额外的工作以保持非规范化数据的一致性。可以通过向数据库发出多个请求在应用程序代码中模拟连接，但这也将复杂性转移到应用程序中，并且通常比数据库内专门代码执行的连接更慢。在这种情况下，使用文档模型可能导致更复杂的应用程序代码和更差的性能。

通常无法说哪种数据模型会导致更简单的应用程序代码；这取决于数据项之间存在的关系类型。对于高度互联的数据，文档模型是笨拙的，关系模型是可接受的，而图形模型（见“类图形数据模型”）是最自然的。

大多数文档型数据库，以及关系型数据库中的JSON支持，并不对文档中的数据强制实施任何模式。关系型数据库中的XML支持通常带有可选的模式验证。没有模式意味着可以向文档中添加任意键和值，在读取时客户端无法保证文档可能包含哪些字段。

文档型数据库有时被称为无模式，但这是误导，因为读取数据的代码通常假定某种结构——即，存在隐含的模式，但不是由数据库强制执行。更准确的术语是读时模式（数据的结构是隐含的，只在读取数据时解释），与写时模式相对（关系型数据库的传统方法，其中模式是显式的，数据库确保所有写入的数据都符合它）。

读时模式类似于编程语言中的动态（运行时）类型检查，而写时模式类似于静态（编译时）类型检查。就像静态和动态类型检查的倡导者对它们的相对优点进行了大量辩论一样，数据库中模式的强制执行也是一个有争议的话题，总的来说没有对或错。

在应用想要改变其数据格式的情况下，两种方法之间的区别尤其明显

模式更改有着执行缓慢和需要停机的坏名声。这个名声并不完全是应得的：大多数关系型数据库系统执行ALTER TABLE语句只需几毫秒。MySQL是一个显著的例外——它在ALTER TABLE时复制整个表，这可能意味着在更改大表时需要几分钟甚至几小时的停机时间——尽管有各种工具可以绕过这个限制。

在任何数据库上，对大表运行UPDATE语句可能都会很慢，因为每一行都需要重写。如果这是不可接受的，应用程序可以让first_name保持默认的NULL，并在读取时填充，就像它在文档型数据库中所做的那样。
